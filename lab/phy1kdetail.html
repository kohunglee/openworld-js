<canvas id="m" style="display: block; width: 992px; height: 827px;" width="12" height="10"></canvas>
<script>
	/**
	 * 3D柔性体物理引擎（Soft-body allPointhysics Engine）
	*/
	  var a = document.getElementById('m');
	  var b = document.body;
	  var c = a.getContext("2d");
	  /* -------------------- */
	
	faceNum=0;  // 粒子的数量
	M=1;  // 模式：1 代表创造模式，0 代表模拟
	B=1;  // 用于实现一个“闪光”的开场特效
	W=1200;  // 画布的宽度

	b.onclick = function(){M=!M};  // 每按一下屏幕，就重新生成新物体 
	
	H = a.height *= W/a.width;  //+ 画布尺寸初始化
	a.width = W;
  
	setInterval(function() {  // 一个每秒 66 帧的动画

	  if (M) {  // 生成原始模型
	  	  index        = 0;  // 计数器
		  allPoint     = [];  // 存放所有的小珠子
		  longArr      = [];  // 储存组织的线，（珠子间的长度）
	  	  radius       = 450;  // 物体的直径（？？半径）

		//   faceNum      = 0|Math.random()*9+13; // 决定物体的面数：随机生成一个 3~11 的随机整数
		//   initRoSpeed  = .3+Math.random()/2;  // 物体初始旋转速度
		//   initLen      = radius*Math.random()+30;  // 物体的初始长度
		//   inclined     = Math.random()*(faceNum%2)/2+1;  // ？？交错生成内外层粒子的参数

		  /* 一个测试的预设数值 */
		  faceNum      = 6;
		  initRoSpeed  = 0.1;
		  initLen      = 200;
		  inclined     = 1.9;

		  for (i=faceNum; i--;) {  // 根据蓝图，生成模型的「珠子」，每面生成一次
			allPoint[index++] = initPointData(radius, initLen, faceNum, inclined, initRoSpeed);

			initLen = -initLen;  //+ ？？交错参数，翻转半径，为下一个点做准备
			inclined = 1/inclined;
		  	allPoint[index++] = initPointData(radius, initLen, faceNum, inclined, initRoSpeed);

			initLen = -initLen;  //+ 再次翻转，恢复原样
			inclined = 1/inclined;
		  }

		  faceNum = index;  // 更新粒子总数
		  M=0;  // 开始模拟模式
		  index=0;  // 计数器归 0

		  for (i=faceNum; i--;) {  // 测量与记录线（橡皮筋）的长度
				j = (i+1)%faceNum;  // j 是 i 的下一个点（邻居）
		  		longArr[index++] = measureLen(i, j, allPoint);  // 将测量好的距离，记录到 longArr 里
		  		j = (i+2)%faceNum;
		  		longArr[index++] = measureLen(i, j, allPoint);
		  		j = (i+1+faceNum/2)%faceNum;
		  		longArr[index++] = measureLen(i, j, allPoint);
		  }
	  }


      for (q=15; q--;) {  // 每帧循环 15 次，等于模拟的速率吧
		  for (i=faceNum; i--;) {		//  重置受力
				allPoint[i].f=allPoint[i].h=index=0;  // 清空每个原子在 X 和 Z 上的受力
				allPoint[i].g=1/W;		// 重力，每个点都要收的一个微小，向下的力
		  }
		  
		  for (i=faceNum; i--;) {  // 虎克定律
		  		j = (i+1)%faceNum;  // 找到邻居 J
		  	  	u = allPoint[i].x - allPoint[j].x;
				v = allPoint[i].y - allPoint[j].y;
				w = allPoint[i].z - allPoint[j].z;
				l = Math.sqrt(u*u + v*v + w*w);  // 勾股定理
				u = u/l; v = v/l; w = w/l;  // i 指向 j 的方向向量
				
				b = (allPoint[i].v-allPoint[j].v)*u +  // 两个点在该方向上的相对速度。阻尼效果，让物体慢慢停止振动
					(allPoint[i].u-allPoint[j].u)*v +
					(allPoint[i].q-allPoint[j].q)*w;
				
				initRoSpeed = -(l-longArr[index++]+b)/40;	// 核心公式，弹力 initRoSpeed=（当前长度-舒适长度+阻尼），其中 /40 是弹簧的硬度		  	    
		  	    
				allPoint[i].f += initRoSpeed*u;  // 弹力分解到 X 轴
				allPoint[i].g += initRoSpeed*v;  // 弹力分解到 Y 轴
				allPoint[i].h += initRoSpeed*w;  // 弹力分解到 Z 轴

				allPoint[j].f -= initRoSpeed*u;  //+ 根据牛顿第三定律，反作用力（下同）
				allPoint[j].g -= initRoSpeed*v;
				allPoint[j].h -= initRoSpeed*w;
				
			// --- 下面的两段代码完全重复上面的逻辑，只是作用于“隔壁邻居”和“对面邻居”的橡皮筋 ---

				j = (i+2)%faceNum;  // 
				u = allPoint[i].x - allPoint[j].x;
				v = allPoint[i].y - allPoint[j].y;
				w = allPoint[i].z - allPoint[j].z;
				l = Math.sqrt(u*u + v*v + w*w);
				u = u/l; v = v/l; w = w/l;
				
				b =  (allPoint[i].v-allPoint[j].v)*u + (allPoint[i].u-allPoint[j].u)*v + (allPoint[i].q-allPoint[j].q)*w;
				
				initRoSpeed = -(l-longArr[index++]+b)/40;	
		  	    
		  	    allPoint[i].f += initRoSpeed*u;		
				allPoint[i].g += initRoSpeed*v;
				allPoint[i].h += initRoSpeed*w;
				
				allPoint[j].f -= initRoSpeed*u;
				allPoint[j].g -= initRoSpeed*v;
				allPoint[j].h -= initRoSpeed*w;
				
				j = (i+1+faceNum/2)%faceNum;
				u = allPoint[i].x - allPoint[j].x;
				v = allPoint[i].y - allPoint[j].y;
				w = allPoint[i].z - allPoint[j].z;
				l = Math.sqrt(u*u + v*v + w*w);
				u = u/l; v = v/l; w = w/l;
				
				b =  (allPoint[i].v-allPoint[j].v)*u + (allPoint[i].u-allPoint[j].u)*v + (allPoint[i].q-allPoint[j].q)*w;
				
				initRoSpeed = -(l-longArr[index++]+b)/40;	//Internal forces  	  
		  	    
		  	    allPoint[i].f += initRoSpeed*u;			//Newtons 3rd law
				allPoint[i].g += initRoSpeed*v;
				allPoint[i].h += initRoSpeed*w;
				
				allPoint[j].f -= initRoSpeed*u;
				allPoint[j].g -= initRoSpeed*v;
				allPoint[j].h -= initRoSpeed*w;
		  }
		  
		  for (i=faceNum; i--;) {  // 牛二定理， F=ma -> a=F/m (m=1)
				allPoint[i].v += allPoint[i].f;  // 将合力转化为加速度，更新 X 轴速度 u，下同
				allPoint[i].u += allPoint[i].g;
				allPoint[i].q += allPoint[i].h;
	
				allPoint[i].x += allPoint[i].v*9;  // 根据新的速度，更新 X 轴的位置（9 用于控制模拟速度）
				allPoint[i].y += allPoint[i].u*9;
				allPoint[i].z += allPoint[i].q*9;
							
				if (allPoint[i].y>200) {  // 碰撞检测，如果到 y=200 以上（可能是地面）
				  initRoSpeed = allPoint[i].g/2;  // 计算一个摩擦力，它与压力有关
				  allPoint[i].u = allPoint[i].g = w = 0;  // 粗暴停止向下的速度，w 清零
				  u = allPoint[i].v;  // 临时借用 u、v、l...，不是很理解这是什么
				  v = allPoint[i].q;
				  l = Math.sqrt(u*u + v*v + w*w);
				  u = u/l; v = v/l; w = w/l;
				  
				    allPoint[i].v -= initRoSpeed*u;  // 施加 X 轴摩擦力，让它减速
				    allPoint[i].q -= initRoSpeed*v;  // Z 轴
				  
				  	allPoint[i].y = 200;  // 强制将 y 轴位置拉回 200
				}

				if (allPoint[i].z>-200) {  // 如果撞到背景墙
    			  if (allPoint[i].q>0) {
					B=0;  // 关闭闪光特效
					allPoint[i].q = 0;  // 停止 Z 轴速度
					allPoint[i].z = -200  // 粘到墙上
				  };
    			}	
    						
		  }
		}

	/* ----- 三维渲染 ----- */

		T=-1;  // 临时变量重置
		C=99;  // 改变颜色用
		c.clearRect(0,0,W,H);  // 清空画板
		c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";  // 画笔颜色，一个洋红色
      	c.fillRect(0,0,W,H);  // 涂满背景
      	C=200;  // 恢复青色
		c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";
      	c.fillRect(0,0,W,W/4);  // 顶部的矩形
		C=initLen;  // 获取一个随机颜色
		for (i=faceNum; i--;) {	// 3D 投影绘制
	 		j = (i+1)%faceNum;  // i 的邻居 J
	 		u = allPoint[i].x - allPoint[j].x;
			v = allPoint[i].y - allPoint[j].y;
			w = allPoint[i].z - allPoint[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			U = u/l; V = v/l; Q = w/l;  // 计算从 i 到 j 的方向
				

		  	j = (i+2)%faceNum;  // i 的另一个邻居
	 		u = allPoint[i].x - allPoint[j].x;
			v = allPoint[i].y - allPoint[j].y;
			w = allPoint[i].z - allPoint[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			u = u/l; v = v/l; w = w/l;

		  	T = (v*Q-w*V)*allPoint[i].x -  // 向量叉乘计算光照
			    (u*Q-w*U)*allPoint[i].y +  // ，结果的正负带边main收否朝向（背向）我们
			    (u*V-v*U)*allPoint[i].z;
	 		
	 		u = allPoint[i].x;
			v = allPoint[i].y;
			w = allPoint[i].z;
			l = Math.sqrt(u*u + v*v + w*w);  // 计算 i 点到原点的距离
			
		  	c.beginPath();
	  		m=allPoint[i];  // m 是当前原子
			f = 3*200/(200-m.z);  // 核心投影透视公式，计算缩放因子 f

		  	c.moveTo( m.x*f+W/4, m.y*f + W/4 );  // 将原子的坐标转换为 2D 坐标，第一个点
		  	j = (i+1)%faceNum;  // 找到 i 的邻居
		  	m=allPoint[j]; f = 3*200/(200-m.z);  // 同样，计算透视后的缩放因子 f
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );  // 两点之间的连线
		  	j = (i+3)%faceNum;  // 第 4 个原子（构成一个四边形）
		  	m=allPoint[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+2)%faceNum;  // 第三个原子
		  	m=allPoint[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	T=T/l/-2;  // 根据光照和距离，来调整亮度 T
		 	if ((!(i%2))&(T<=0)) {  // 如果这个面是偶数面（避免重复绘制），且朝向我们
			  	c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";  // 根据亮度 T 来填充颜色，？T 越小越亮
			  	c.fill();  // 填充四边形
		  	}
		  	c.stroke();  // 给四边形描个边
		  	
		}

		for (i=faceNum; i--;) {  // 上一个绘制循环的重复，作用未知
	 		j = (i+1)%faceNum;
	 		u = allPoint[i].x - allPoint[j].x;
			v = allPoint[i].y - allPoint[j].y;
			w = allPoint[i].z - allPoint[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			U = u/l; V = v/l; Q = w/l; 
				
		  	j = (i+2)%faceNum;
	 		u = allPoint[i].x - allPoint[j].x;
			v = allPoint[i].y - allPoint[j].y;
			w = allPoint[i].z - allPoint[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			u = u/l; v = v/l; w = w/l;

		  	T = (v*Q-w*V)*allPoint[i].x - (u*Q-w*U)*allPoint[i].y + (u*V-v*U)*allPoint[i].z;
	 		
	 		u = allPoint[i].x;
			v = allPoint[i].y;
			w = allPoint[i].z;
			l = Math.sqrt(u*u + v*v + w*w);
			
		  	c.beginPath();
	  		m=allPoint[i]; f = 3*200/(200-m.z);
		  	c.moveTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+1)%faceNum;
		  	m=allPoint[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+3)%faceNum;
		  	m=allPoint[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+2)%faceNum;
		  	m=allPoint[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	T=T/l;
		  	if ((!(i%2))&(T<=0)) {
			  	c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";
			  	c.fill();
		  	}
		}
      	
      	B=(B<1)?B+=.1:1;	// 让闪光逐渐退去，（0 -> 1）
	  },15);


// 初始化 顶点 的数据
function initPointData(radius, initLen, faceNum, inclined, initRoSpeed){
  return {
			x: radius-initLen,  //+ 生成 xyz 坐标
			y: (-W + radius * inclined * Math.sin(6.3/ faceNum * i)),  // 6.3 ~ 2π
			z: (-3 * W + radius * inclined * Math.sin(6.3/faceNum*i+1.6)),
			v: 0.2,  // Vx 速度
			u: inclined * Math.sin(6.3 / faceNum * i + 1.6) * initRoSpeed,  // Vy 速度
			q: -inclined * Math.sin(6.3/faceNum*i) * initRoSpeed,  // Vz 速度
			f: 0,  // 初始受力 Fx 力
			g: 0,  // Fy 力
			h: 0   // Fz 力
		}
}

// 勾股定理测量完的数据
function measureLen(i, j, allPoint){
	u = allPoint[i].x - allPoint[j].x;
	v = allPoint[i].y - allPoint[j].y;
	w = allPoint[i].z - allPoint[j].z;
	l = Math.sqrt(u*u + v*v + w*w);
	return l;
}
</script>