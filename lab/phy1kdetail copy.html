<canvas id="m" style="display: block; width: 992px; height: 827px;" width="12" height="10"></canvas>
<script>
	/**
	 * 3D柔性体物理引擎（Soft-body Physics Engine）
	*/
	  var a = document.getElementById('m');
	  var b = document.body;
	  var c = a.getContext("2d");
	  /* -------------------- */
	p=0;  // 粒子的数量
	M=1;  // 模式：1 代表创造模式，0 代表模拟
	B=1;  // 用于实现一个“闪光”的开场特效
	W=1200;  // 画布的宽度

	b.onclick = function(){M=!M};  // 每按一下屏幕，就重新生成新物体 
	  
	H = a.height *= W/a.width;  //+ 画布尺寸初始化
	a.width = W;
  
	  setInterval(function() {  // 一个每秒 66 帧的动画
	 
	  // 创造模式
	  if (M) {  // 开始创造
	  	  s=0;  // 计数器
		  P=[];  // 存放所有的小珠子
		  S=[];  // 储存组织的线，（珠子间的长度）
	  	  C=200;  // 一个用于计算的常量

		  p = 0|Math.random()*9+13; // 决定物体的面数：随机生成一个 3~11 的随机整数
		  T = .3+Math.random()/2;  // 物体初始旋转速度
		  R = C*Math.random()+30;  // 物体的初始半径

		  p = 4;

		  t = Math.random()*(p%2)/2+1;  // ？？交错生成内外层粒子的参数

		  for (i=p; i--;) {  // 根据蓝图，生成模型的「珠子」
		  	P[s++] = {
				x:C-R,  //+ 生成 xyz 坐标
				y:(-W+C*t*Math.sin(6.3/p*i)),  // 6.3 ~ 2π
				z:(-3*W+C*t*Math.sin(6.3/p*i+1.6)),
				v:0.2,  // Vx 速度
				u:t*Math.sin(6.3/p*i+1.6)*T,  // Vy 速度
				q:-t*Math.sin(6.3/p*i)*T,  // Vz 速度
				f:0,  // 初始受力 Fx 力
				g:0,  // Fy 力
				h:0   // Fz 力
			};
			R=-R;  //+ ？？交错参数，翻转半径，为下一个点做准备
			t=1/t;
		  	P[s++] = {  // 差不多同上
				x:C-R,
				y:(-W+C*t*Math.sin(6.3/p*i)),
				z:(-3*W+C*t*Math.sin(6.3/p*i+1.6)),
				v:0,
				u:t*Math.sin(6.3/p*i+1.6)*T,
				q:-t*Math.sin(6.3/p*i)*T,
				f:0,
				g:0,
				h:0
			};
			R=-R;  //+ 再次翻转，恢复原样
			t=1/t;
		  }

		  p=s;  // 更新粒子总数
		  M=0;  // 开始模拟模式
		  s=0;  // 计数器归 0

		  for (i=p; i--;) {  // 测量与记录线（橡皮筋）的长度
				j = (i+1)%p;  // j 是 i 的下一个点（邻居）
				u = P[i].x - P[j].x;  //+ 测量 X 的距离（下同）
				v = P[i].y - P[j].y;
				w = P[i].z - P[j].z;
				l = Math.sqrt(u*u + v*v + w*w);  // 测量三维距离（勾股定理）
		  		S[s++] = l;  // 将测量好的距离，记录到 S 里
		  		
		  		j = (i+2)%p;  // 找到 i 的邻居
				u = P[i].x - P[j].x;
				v = P[i].y - P[j].y;
				w = P[i].z - P[j].z;
				l = Math.sqrt(u*u + v*v + w*w);
		  		S[s++] = l;  // 更长的线的长度
	
		  		j = (i+1+p/2)%p;  // 找到 i 的环对面的哪个原子
				u = P[i].x - P[j].x;
				v = P[i].y - P[j].y;
				w = P[i].z - P[j].z;
				l = Math.sqrt(u*u + v*v + w*w);
		  		S[s++] = l;  // 记录其长度
		  }
	  }


      for (q=15; q--;) {  // 每帧循环 15 次，等于模拟的速率吧
		  for (i=p; i--;) {		//  重置受力
				P[i].f=P[i].h=s=0;  // 清空每个原子在 X 和 Z 上的受力
				P[i].g=1/W;		// 重力，每个点都要收的一个微小，向下的力
		  }
		  
		  for (i=p; i--;) {  // 虎克定律
		  		j = (i+1)%p;  // 找到邻居 J
		  	  	u = P[i].x - P[j].x;
				v = P[i].y - P[j].y;
				w = P[i].z - P[j].z;
				l = Math.sqrt(u*u + v*v + w*w);  // 勾股定理
				u = u/l; v = v/l; w = w/l;  // i 指向 j 的方向向量
				
				b = (P[i].v-P[j].v)*u +  // 两个点在该方向上的相对速度。阻尼效果，让物体慢慢停止振动
					(P[i].u-P[j].u)*v +
					(P[i].q-P[j].q)*w;
				
				T = -(l-S[s++]+b)/40;	// 核心公式，弹力 T=（当前长度-舒适长度+阻尼），其中 /40 是弹簧的硬度		  	    
		  	    
				P[i].f += T*u;  // 弹力分解到 X 轴
				P[i].g += T*v;  // 弹力分解到 Y 轴
				P[i].h += T*w;  // 弹力分解到 Z 轴

				P[j].f -= T*u;  //+ 根据牛顿第三定律，反作用力（下同）
				P[j].g -= T*v;
				P[j].h -= T*w;
				
			// --- 下面的两段代码完全重复上面的逻辑，只是作用于“隔壁邻居”和“对面邻居”的橡皮筋 ---

				j = (i+2)%p;  // 
				u = P[i].x - P[j].x;
				v = P[i].y - P[j].y;
				w = P[i].z - P[j].z;
				l = Math.sqrt(u*u + v*v + w*w);
				u = u/l; v = v/l; w = w/l;
				
				b =  (P[i].v-P[j].v)*u + (P[i].u-P[j].u)*v + (P[i].q-P[j].q)*w;
				
				T = -(l-S[s++]+b)/40;	
		  	    
		  	    P[i].f += T*u;		
				P[i].g += T*v;
				P[i].h += T*w;
				
				P[j].f -= T*u;
				P[j].g -= T*v;
				P[j].h -= T*w;
				
				j = (i+1+p/2)%p;
				u = P[i].x - P[j].x;
				v = P[i].y - P[j].y;
				w = P[i].z - P[j].z;
				l = Math.sqrt(u*u + v*v + w*w);
				u = u/l; v = v/l; w = w/l;
				
				b =  (P[i].v-P[j].v)*u + (P[i].u-P[j].u)*v + (P[i].q-P[j].q)*w;
				
				T = -(l-S[s++]+b)/40;	//Internal forces  	  
		  	    
		  	    P[i].f += T*u;			//Newtons 3rd law
				P[i].g += T*v;
				P[i].h += T*w;
				
				P[j].f -= T*u;
				P[j].g -= T*v;
				P[j].h -= T*w;
		  }
		  
		  for (i=p; i--;) {  // 牛二定理， F=ma -> a=F/m (m=1)
				P[i].v += P[i].f;  // 将合力转化为加速度，更新 X 轴速度 u，下同
				P[i].u += P[i].g;
				P[i].q += P[i].h;
	
				P[i].x += P[i].v*9;  // 根据新的速度，更新 X 轴的位置（9 用于控制模拟速度）
				P[i].y += P[i].u*9;
				P[i].z += P[i].q*9;
							
				if (P[i].y>200) {  // 碰撞检测，如果到 y=200 以上（可能是地面）
				  T = P[i].g/2;  // 计算一个摩擦力，它与压力有关
				  P[i].u = P[i].g = w = 0;  // 粗暴停止向下的速度，w 清零
				  u = P[i].v;  // 临时借用 u、v、l...，不是很理解这是什么
				  v = P[i].q;
				  l = Math.sqrt(u*u + v*v + w*w);
				  u = u/l; v = v/l; w = w/l;
				  
				    P[i].v -= T*u;  // 施加 X 轴摩擦力，让它减速
				    P[i].q -= T*v;  // Z 轴
				  
				  	P[i].y = 200;  // 强制将 y 轴位置拉回 200
				}

				if (P[i].z>-200) {  // 如果撞到背景墙
    			  if (P[i].q>0) {
					B=0;  // 关闭闪光特效
					P[i].q = 0;  // 停止 Z 轴速度
					P[i].z = -200  // 粘到墙上
				  };
    			}	
    						
		  }
		}

		/* ----- 三维渲染 ----- */

		T=-1;  // 临时变量重置
		C=99;  // 改变颜色用
		c.clearRect(0,0,W,H);  // 清空画板
		c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";  // 画笔颜色，一个洋红色
      	c.fillRect(0,0,W,H);  // 涂满背景
      	C=200;  // 恢复青色
		c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";
      	c.fillRect(0,0,W,W/4);  // 顶部的矩形
		C=R;  // 获取一个随机颜色
		for (i=p; i--;) {	// 3D 投影绘制
	 		j = (i+1)%p;  // i 的邻居 J
	 		u = P[i].x - P[j].x;
			v = P[i].y - P[j].y;
			w = P[i].z - P[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			U = u/l; V = v/l; Q = w/l;  // 计算从 i 到 j 的方向
				

		  	j = (i+2)%p;  // i 的另一个邻居
	 		u = P[i].x - P[j].x;
			v = P[i].y - P[j].y;
			w = P[i].z - P[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			u = u/l; v = v/l; w = w/l;

		  	T = (v*Q-w*V)*P[i].x -  // 向量叉乘计算光照
			    (u*Q-w*U)*P[i].y +  // ，结果的正负带边main收否朝向（背向）我们
			    (u*V-v*U)*P[i].z;
	 		
	 		u = P[i].x;
			v = P[i].y;
			w = P[i].z;
			l = Math.sqrt(u*u + v*v + w*w);  // 计算 i 点到原点的距离
			
		  	c.beginPath();
	  		m=P[i];  // m 是当前原子
			f = 3*200/(200-m.z);  // 核心投影透视公式，计算缩放因子 f

		  	c.moveTo( m.x*f+W/4, m.y*f + W/4 );  // 将原子的坐标转换为 2D 坐标，第一个点
		  	j = (i+1)%p;  // 找到 i 的邻居
		  	m=P[j]; f = 3*200/(200-m.z);  // 同样，计算透视后的缩放因子 f
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );  // 两点之间的连线
		  	j = (i+3)%p;  // 第 4 个原子（构成一个四边形）
		  	m=P[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+2)%p;  // 第三个原子
		  	m=P[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	T=T/l/-2;  // 根据光照和距离，来调整亮度 T
		 	if ((!(i%2))&(T<=0)) {  // 如果这个面是偶数面（避免重复绘制），且朝向我们
			  	c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";  // 根据亮度 T 来填充颜色，？T 越小越亮
			  	c.fill();  // 填充四边形
		  	}
		  	c.stroke();  // 给四边形描个边
		  	
		}

		for (i=p; i--;) {  // 上一个绘制循环的重复，作用未知
	 		j = (i+1)%p;
	 		u = P[i].x - P[j].x;
			v = P[i].y - P[j].y;
			w = P[i].z - P[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			U = u/l; V = v/l; Q = w/l; 
				
		  	j = (i+2)%p;
	 		u = P[i].x - P[j].x;
			v = P[i].y - P[j].y;
			w = P[i].z - P[j].z;
			l = Math.sqrt(u*u + v*v + w*w);
			u = u/l; v = v/l; w = w/l;

		  	T = (v*Q-w*V)*P[i].x - (u*Q-w*U)*P[i].y + (u*V-v*U)*P[i].z;
	 		
	 		u = P[i].x;
			v = P[i].y;
			w = P[i].z;
			l = Math.sqrt(u*u + v*v + w*w);
			
		  	c.beginPath();
	  		m=P[i]; f = 3*200/(200-m.z);
		  	c.moveTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+1)%p;
		  	m=P[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+3)%p;
		  	m=P[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	j = (i+2)%p;
		  	m=P[j]; f = 3*200/(200-m.z);
		  	c.lineTo( m.x*f+W/4, m.y*f + W/4 );
		  	T=T/l;
		  	if ((!(i%2))&(T<=0)) {
			  	c.fillStyle="hsla("+C+",99%," + -80*T +"%,"+B+")";
			  	c.fill();
		  	}
		}
      	
      	B=(B<1)?B+=.1:1;	// 让闪光逐渐退去，（0 -> 1）
	  },15);

</script>